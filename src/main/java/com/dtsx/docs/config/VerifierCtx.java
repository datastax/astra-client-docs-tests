package com.dtsx.docs.config;

import com.dtsx.docs.lib.ExternalPrograms;
import com.dtsx.docs.lib.ExternalPrograms.ExternalProgram;
import com.dtsx.docs.lib.ExternalPrograms.ExternalProgramType;
import com.dtsx.docs.runner.drivers.ClientDriver;
import com.dtsx.docs.runner.drivers.ClientLanguage;
import com.dtsx.docs.runner.reporter.TestReporter;
import com.dtsx.docs.runner.verifier.VerifyMode;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.val;
import picocli.CommandLine;
import picocli.CommandLine.Model.CommandSpec;
import picocli.CommandLine.ParameterException;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Stream;

import static com.dtsx.docs.runner.verifier.VerifyMode.DRY_RUN;

/// **Note: Docs for this class were generated by AI**
///
/// The runtime context for the verifier, containing all configuration and dependencies needed to run tests.
///
/// Built from [VerifierArgs] via `args.toCtx(spec)`, this validates everything is set up correctly:
/// - Database connection info (token + endpoint)
/// - Examples folder exists with required `_base/` and `_fixtures/` subdirectories
/// - All required external programs are installed (tsx, npm, language-specific tools)
/// - Client drivers are configured with correct artifact versions
///
/// @see VerifierArgs
@Getter
public class VerifierCtx {
    /// Parsed from `-t`/`--astra-token` flag or `ASTRA_TOKEN` env var, and `-e`/`--api-endpoint` flag or `API_ENDPOINT` env var.
    ///
    /// The token must have read/write access to the test database, and the endpoint
    /// determines whether we're testing against a collection or table API.
    private final ConnectionInfo connectionInfo;

    /// Resolved from `EXAMPLES_FOLDER` env var, with fallback to `./resources/mock_examples`.
    ///
    /// If the provided path doesn't have `_base/` and `_fixtures/` subdirectories,
    /// automatically tries `<path>/modules/api-reference/examples` (for docs repo structure).
    private final Path examplesFolder;

    /// Resolved from `SNAPSHOTS_FOLDER` env var, with fallback to `./snapshots`.
    ///
    /// Snapshots can be shared across languages (one file per test root) or separate
    /// (one file per language per test root), controlled by `share: true/false` in meta.yml.
    private final Path snapshotsFolder;

    /// Always `.docs_tests_temp/` - contains execution environments and intermediate files.
    ///
    /// Deleted on startup if `--clean` is set, and optionally deleted after tests complete.
    private final Path tmpFolder;

    @Getter(AccessLevel.NONE)
    private final Path execEnvTemplatesFolder;

    /// Built from `CLIENT_DRIVERS` env var (e.g., `typescript,python,java`).
    ///
    /// Each driver is initialized with its artifact version from either:
    /// - `<LANG>_ARTIFACT` env var (e.g., `TYPESCRIPT_ARTIFACT=@datastax/astra-db-ts@v2.0.0`)
    /// - `-A` flag (e.g., `-Atypescript=@datastax/astra-db-ts@v2.0.0`)
    /// - Language's default version
    private final Map<ClientLanguage, ClientDriver> drivers;

    /// Parsed from `TEST_REPORTER` env var (default: `all_tests`).
    ///
    /// Controls output verbosity:
    /// - `all_tests`: Shows all test results
    /// - `only_failures`: Only shows failed tests
    private final TestReporter reporter;

    /// Resolved from `--verify-mode` flag or `VERIFY_MODE` env var (default: `normal`).
    ///
    /// - `normal`: Runs tests and verifies snapshots
    /// - `verify_only`: Skips test execution, only checks existing snapshots
    /// - `dry_run`: Prints what would run without executing anything
    private final VerifyMode verifyMode;

    /// Set by `--clean` flag or `CLEAN` env var (default: false).
    ///
    /// When true, deletes `.docs_tests_temp/` after all tests complete.
    private final boolean clean;

    /// Set by `--bail` flag or `BAIL` env var (default: false).
    ///
    /// When true, stops test execution upon the first failure.
    private final boolean bail;

    /// Built from `<PROGRAM>_COMMAND` env vars (e.g., `TSX_COMMAND=npx -y tsx`).
    ///
    /// Allows overriding default program paths when they're not in PATH or you need
    /// a specific version (e.g., `PYTHON_COMMAND=python3.11`).
    private final Map<ExternalProgramType, String[]> commandOverrides;

    /// Built from `--filter` and `--filter-not` flags (or `FILTERS`/`INVERSE_FILTERS` env vars).
    ///
    /// Uses regex matching on full file paths. For example:
    /// - `--filter dates` matches `examples/dates/example.ts`
    /// - `--filter-not java` excludes `examples/dates/example.java`
    private final Predicate<Path> filter;

    /// Returns `resources/environments/<language>/` containing the base project structure.
    ///
    /// For example, `typescript/` contains `package.json`, `java/` contains `build.gradle`.
    /// These are copied to `.docs_tests_temp/execution_environments/<language>/` at runtime.
    public Path executionEnvironmentTemplate(ClientLanguage lang) {
        return execEnvTemplatesFolder.resolve(lang.name().toLowerCase());
    }

    /// Returns the languages specified in `CLIENT_DRIVERS` (e.g., `[TYPESCRIPT, PYTHON, JAVA]`).
    public List<ClientLanguage> languages() {
        return new ArrayList<>(drivers.keySet());
    }

    public VerifierCtx(VerifierArgs args, CommandSpec spec) {
        val cmd = spec.commandLine();

        this.connectionInfo = mkConnectionInfo(cmd, args);

        this.examplesFolder = resolveExampleFolder(cmd, args);
        this.snapshotsFolder = ArgUtils.requirePath(cmd, args.$snapshotsFolder, "snapshots folder", "-sf", "SNAPSHOTS_FOLDER");
        this.tmpFolder = Path.of(".docs_tests_temp");
        this.execEnvTemplatesFolder = Path.of("resources/environments/");

        this.drivers = mkDrivers(cmd, args);
        this.reporter = TestReporter.parse(this, args.$reporter);
        this.verifyMode = resolveVerifyMode(cmd, args, drivers.keySet());

        this.clean = args.$clean;
        this.bail = args.$bail;

        this.commandOverrides = mkCommandOverrides(args);
        this.filter = mkFilter(args.$filters, args.$inverseFilters);

        verifyRequiredProgramsAvailable(cmd);
    }

    private Path resolveExampleFolder(CommandLine cmd, VerifierArgs args) {
        val folder = ArgUtils.requirePath(cmd, args.$examplesFolder, "examples folder", "-ef", "EXAMPLES_FOLDER");

        Predicate<Path> isValidExampleFolder = (path) -> {
            return Stream.of(path, path.resolve("_base"), path.resolve("_fixtures")).allMatch(Files::isDirectory);
        };

        if (isValidExampleFolder.test(folder)) {
            return folder;
        }

        val nestedFolder = folder.resolve("modules/api-reference/examples");

        if (isValidExampleFolder.test(nestedFolder)) {
            return nestedFolder;
        }

        throw new ParameterException(cmd, "Neither " + folder + " nor " + nestedFolder + " is the expected examples folder.");
    }

    private ConnectionInfo mkConnectionInfo(CommandLine cmd, VerifierArgs args) {
        val token = ArgUtils.requireFlag(cmd, args.$token, "astra token", "-t", "ASTRA_TOKEN");
        val apiEndpoint = ArgUtils.requireFlag(cmd, args.$apiEndpoint, "API endpoint", "-e", "API_ENDPOINT");
        return ConnectionInfo.parse(token, apiEndpoint);
    }

    private Map<ClientLanguage, ClientDriver> mkDrivers(CommandLine cmd, VerifierArgs args) {
        ArgUtils.requireParameter(cmd, args.$drivers.stream().findFirst(), "client driver", 1, "CLIENT_DRIVER");

        val driversMap = new HashMap<ClientLanguage, ClientDriver>();

        for (val lang : args.$drivers) {
            val usesArtifact = lang.defaultArtifact() != null;

            val envVarName = lang.name().toUpperCase() + "_ARTIFACT";
            val resolvedArtifact = Optional.ofNullable(args.$artifactOverrides.get(lang)).or(() -> Optional.ofNullable(System.getProperty(envVarName)));

            if (resolvedArtifact.isPresent() && !usesArtifact) {
                throw new ParameterException(cmd, lang.name() + " does not support artifact overrides.");
            }

            driversMap.put(lang, lang.mkDriver().apply(resolvedArtifact.orElse(lang.defaultArtifact())));
        }

        return driversMap;
    }

    private VerifyMode resolveVerifyMode(CommandLine cmd, VerifierArgs args, Set<ClientLanguage> languages) {
        if (languages.size() > 1 && args.$verifyMode == VerifyMode.NORMAL) {
            throw new ParameterException(cmd, "When using multiple client drivers, --verify-mode must be either 'verify_only' or 'dry_run'.");
        }

        return (args.$dryRun)
            ? DRY_RUN
            : args.$verifyMode;
    }

    private Map<ExternalProgramType, String[]> mkCommandOverrides(VerifierArgs args) {
        val overrides = new HashMap<ExternalProgramType, String[]>();

        for (val programType : ExternalProgramType.values()) {
            val envVarName = programType.name().toUpperCase() + "_COMMAND";

            Optional.ofNullable(System.getenv(envVarName)).or(() -> Optional.ofNullable(System.getProperty(envVarName))).ifPresent((value) -> {
                overrides.put(programType, value.split(" "));
            });
        }

        for (val override : args.$commandOverrides.entrySet()) {
            overrides.put(override.getKey(), override.getValue().split(" "));
        }

        return overrides;
    }

    private Predicate<Path> mkFilter(List<String> filters, List<String> inverseFilters) {
        val includePredicate = mkFilterPredicates(filters)
            .orElse(_ -> true);

        val excludePredicate = mkFilterPredicates(inverseFilters)
            .map(Predicate::negate)
            .orElse(_ -> true);

        return includePredicate.and(excludePredicate);
    }

    private Optional<Predicate<Path>> mkFilterPredicates(List<String> filter) {
        return filter.stream()
            .map(String::trim)
            .filter(s -> !s.isBlank())
            .map((s) -> (Predicate<Path>) (path) -> path.toString().matches(".*" + s + ".*"))
            .reduce(Predicate::or);
    }

    private void verifyRequiredProgramsAvailable(CommandLine cmd) {
        val requiredPrograms = new HashSet<Function<VerifierCtx, ExternalProgram>>() {{
            add(ExternalPrograms::tsx);
            add(ExternalPrograms::npm);

            for (val driver : drivers.values()) {
                addAll(driver.requiredPrograms());
            }
        }};

        for (val mkProgram : requiredPrograms) {
            val program = mkProgram.apply(this);

            if (!program.exists()) {
                throw new ParameterException(cmd, program.name() + " could not be found. Please install it or set the " + program.envVar() + " environment variable.");
            }
        }
    }
}
