package com.dtsx.docs.commands.test;

import com.dtsx.docs.config.ArgUtils;
import com.dtsx.docs.config.ctx.BaseCtx;
import com.dtsx.docs.config.ctx.BaseScriptRunnerCtx;
import com.dtsx.docs.lib.ExternalPrograms;
import com.dtsx.docs.lib.ExternalPrograms.ExternalProgram;
import com.dtsx.docs.core.runner.drivers.ClientDriver;
import com.dtsx.docs.core.runner.drivers.ClientLanguage;
import com.dtsx.docs.core.runner.tests.VerifyMode;
import com.dtsx.docs.core.runner.tests.reporter.TestReporter;
import lombok.Getter;
import lombok.val;
import org.jetbrains.annotations.MustBeInvokedByOverriders;
import picocli.CommandLine;
import picocli.CommandLine.Model.CommandSpec;
import picocli.CommandLine.ParameterException;

import java.nio.file.Path;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;

import static com.dtsx.docs.core.runner.tests.VerifyMode.DRY_RUN;

/// **Note: Docs for this class were generated by AI**
///
/// The runtime context for the verifier, containing all configuration and dependencies needed to run tests.
///
/// Built from [TestArgs] via `args.toCtx(spec)`, this validates everything is set up correctly:
/// - Database connection info (token + endpoint)
/// - Examples folder exists with required `_base/` and `_fixtures/` subdirectories
/// - All required external programs are installed (tsx, npm, language-specific tools)
/// - Client drivers are configured with correct artifact versions
///
/// @see TestArgs
@Getter
public class TestCtx extends BaseScriptRunnerCtx {
    private final Path snapshotsFolder;
    private final Map<ClientLanguage, ClientDriver> drivers;
    private final TestReporter reporter;
    private final VerifyMode verifyMode;
    private final Predicate<Path> filter;
    private final int maxFixtureInstances;

    public List<ClientLanguage> languages() {
        return new ArrayList<>(drivers.keySet());
    }

    public TestCtx(TestArgs args, CommandSpec spec) {
        super(args, spec);
        this.drivers = mkDrivers(cmd, args);
        this.reporter = args.$reporter.create(this);
        this.verifyMode = resolveVerifyMode(args);
        this.filter = mkFilter(args.$filters, args.$inverseFilters);
        this.snapshotsFolder = examplesFolder().resolve("_snapshots");
        this.maxFixtureInstances = args.$maxFixtureInstances;
    }

    @Override
    @MustBeInvokedByOverriders
    protected Set<Function<BaseCtx, ExternalProgram>> requiredPrograms() {
        return new HashSet<>(super.requiredPrograms()) {{
            add(ExternalPrograms::npm);

            for (val driver : drivers.values()) {
                addAll(driver.requiredPrograms());
            }
        }};
    }

    private Map<ClientLanguage, ClientDriver> mkDrivers(CommandLine cmd, TestArgs args) {
        if (args.$drivers == null || args.$drivers.isEmpty()) {
            throw new ParameterException(cmd, "Must provide at least one client driver (or 'all') to run tests against. Use `-h` for help instead.");
        }

        ArgUtils.requireParameter(cmd, args.$drivers.stream().findFirst(), "client driver", 1, "CLIENT_DRIVER");

        val driversMap = new HashMap<ClientLanguage, ClientDriver>();

        if (args.$drivers.stream().allMatch("all"::equalsIgnoreCase)) {
            args.$drivers = ClientLanguage.names();
        }

        for (val langStr : args.$drivers) {
            val lang = parseClientLanguage(cmd, langStr);
            val driver = mkDriverForLanguage(cmd, lang, args);
            driversMap.put(lang, driver);
        }

        return driversMap;
    }

    private ClientLanguage parseClientLanguage(CommandLine cmd, String langStr) {
        try {
            return ClientLanguage.valueOf(langStr.toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new ParameterException(cmd, "Invalid client language: " + langStr + ". Expected one of: " + String.join(", ", ClientLanguage.names()));
        }
    }

    private VerifyMode resolveVerifyMode(TestArgs args) {
        return (args.$dryRun)
            ? DRY_RUN
            : args.$verifyMode;
    }

    private Predicate<Path> mkFilter(List<String> filters, List<String> inverseFilters) {
        val includePredicate = mkFilterPredicates(filters)
            .orElse(_ -> true);

        val excludePredicate = mkFilterPredicates(inverseFilters)
            .map(Predicate::negate)
            .orElse(_ -> true);

        return includePredicate.and(excludePredicate);
    }

    private Optional<Predicate<Path>> mkFilterPredicates(List<String> filter) {
        return filter.stream()
            .map(String::trim)
            .filter(s -> !s.isBlank())
            .map((s) -> (Predicate<Path>) (path) -> path.toString().matches(".*" + s + ".*"))
            .reduce(Predicate::and);
    }
}
