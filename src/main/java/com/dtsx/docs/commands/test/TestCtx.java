package com.dtsx.docs.commands.test;

import com.dtsx.docs.config.ArgUtils;
import com.dtsx.docs.config.ctx.BaseCtx;
import com.dtsx.docs.config.ctx.BaseScriptRunnerCtx;
import com.dtsx.docs.lib.ExternalPrograms;
import com.dtsx.docs.lib.ExternalPrograms.ExternalProgram;
import com.dtsx.docs.core.runner.drivers.ClientDriver;
import com.dtsx.docs.core.runner.drivers.ClientLanguage;
import com.dtsx.docs.core.runner.tests.VerifyMode;
import com.dtsx.docs.core.runner.tests.reporter.TestReporter;
import lombok.Getter;
import lombok.val;
import org.jetbrains.annotations.MustBeInvokedByOverriders;
import picocli.CommandLine;
import picocli.CommandLine.Model.CommandSpec;
import picocli.CommandLine.ParameterException;

import java.nio.file.Path;
import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;

import static com.dtsx.docs.core.runner.tests.VerifyMode.COMPILE_ONLY;
import static com.dtsx.docs.core.runner.tests.VerifyMode.DRY_RUN;

/// **Note: Docs for this class were generated by AI**
///
/// The runtime context for the verifier, containing all configuration and dependencies needed to run tests.
///
/// Built from [TestArgs] via `args.toCtx(spec)`, this validates everything is set up correctly:
/// - Database connection info (token + endpoint)
/// - Examples folder exists with required `_base/` and `_fixtures/` subdirectories
/// - All required external programs are installed (tsx, npm, language-specific tools)
/// - Client drivers are configured with correct artifact versions
///
/// @see TestArgs
@Getter
public class TestCtx extends BaseScriptRunnerCtx {
    /// Resolved from `SNAPSHOTS_FOLDER` env var, with fallback to `./snapshots`.
    ///
    /// Snapshots can be shared across languages (one file per test root) or separate
    /// (one file per language per test root), controlled by `share: true/false` in meta.yml.
    private final Path snapshotsFolder;

    /// Built from `CLIENT_DRIVERS` env var (e.g., `typescript,python,java`).
    ///
    /// Each driver is initialized with its artifact version from either:
    /// - `<LANG>_ARTIFACT` env var (e.g., `TYPESCRIPT_ARTIFACT=@datastax/astra-db-ts@v2.0.0`)
    /// - `-A` flag (e.g., `-Atypescript=@datastax/astra-db-ts@v2.0.0`)
    /// - Language's default version
    private final Map<ClientLanguage, ClientDriver> drivers;

    /// Parsed from `TEST_REPORTER` env var (default: `all_tests`).
    ///
    /// Controls output verbosity:
    /// - `all_tests`: Shows all test results
    /// - `only_failures`: Only shows failed tests
    private final TestReporter reporter;

    /// Resolved from `--verify-mode` flag or `VERIFY_MODE` env var (default: `normal`).
    ///
    /// - `normal`: Runs tests and verifies snapshots
    /// - `verify_only`: Skips test execution, only checks existing snapshots
    /// - `dry_run`: Prints what would run without executing anything
    private final VerifyMode verifyMode;

    /// Built from `--filter` and `--filter-not` flags (or `FILTERS`/`INVERSE_FILTERS` env vars).
    ///
    /// Uses regex matching on full file paths. For example:
    /// - `--filter dates` matches `examples/dates/example.ts`
    /// - `--filter-not java` excludes `examples/dates/example.java`
    private final Predicate<Path> filter;

    /// Returns the languages specified in `CLIENT_DRIVERS` (e.g., `[TYPESCRIPT, PYTHON, JAVA]`).
    public List<ClientLanguage> languages() {
        return new ArrayList<>(drivers.keySet());
    }

    public TestCtx(TestArgs args, CommandSpec spec) {
        super(args, spec);
        this.drivers = mkDrivers(cmd, args);
        this.reporter = TestReporter.parse(this, args.$reporter);
        this.verifyMode = resolveVerifyMode(args);
        this.filter = mkFilter(args.$filters, args.$inverseFilters);
        this.snapshotsFolder = examplesFolder().resolve("_snapshots");
    }

    @Override
    @MustBeInvokedByOverriders
    protected Set<Function<BaseCtx, ExternalProgram>> requiredPrograms() {
        return new HashSet<>(super.requiredPrograms()) {{
            add(ExternalPrograms::npm);

            for (val driver : drivers.values()) {
                addAll(driver.requiredPrograms());
            }
        }};
    }

    private Map<ClientLanguage, ClientDriver> mkDrivers(CommandLine cmd, TestArgs args) {
        if (args.$drivers == null || args.$drivers.isEmpty()) {
            throw new ParameterException(cmd, "Must provide at least one client driver (or 'all') to run tests against. Use `-h` for help instead.");
        }

        ArgUtils.requireParameter(cmd, args.$drivers.stream().findFirst(), "client driver", 1, "CLIENT_DRIVER");

        val driversMap = new HashMap<ClientLanguage, ClientDriver>();

        if (args.$drivers.stream().allMatch("all"::equalsIgnoreCase)) {
            args.$drivers = ClientLanguage.names();
        }

        for (val langStr : args.$drivers) {
            val lang = parseClientLanguage(cmd, langStr);
            val driver = mkDriverForLanguage(cmd, lang, args);
            driversMap.put(lang, driver);
        }

        return driversMap;
    }

    private ClientLanguage parseClientLanguage(CommandLine cmd, String langStr) {
        try {
            return ClientLanguage.valueOf(langStr.toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new ParameterException(cmd, "Invalid client language: " + langStr + ". Expected one of: " + String.join(", ", ClientLanguage.names()));
        }
    }

    private VerifyMode resolveVerifyMode(TestArgs args) {
        return (args.$dryRun)
            ? DRY_RUN
            : args.$verifyMode;
    }

    private Predicate<Path> mkFilter(List<String> filters, List<String> inverseFilters) {
        val includePredicate = mkFilterPredicates(filters)
            .orElse(_ -> true);

        val excludePredicate = mkFilterPredicates(inverseFilters)
            .map(Predicate::negate)
            .orElse(_ -> true);

        return includePredicate.and(excludePredicate);
    }

    private Optional<Predicate<Path>> mkFilterPredicates(List<String> filter) {
        return filter.stream()
            .map(String::trim)
            .filter(s -> !s.isBlank())
            .map((s) -> (Predicate<Path>) (path) -> path.toString().matches(".*" + s + ".*"))
            .reduce(Predicate::or);
    }
}
