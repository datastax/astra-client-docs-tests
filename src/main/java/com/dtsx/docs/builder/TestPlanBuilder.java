package com.dtsx.docs.builder;

import com.dtsx.docs.builder.MetaYml.SnapshotsConfig;
import com.dtsx.docs.builder.fixtures.JSFixture;
import com.dtsx.docs.config.VerifierCtx;
import com.dtsx.docs.lib.CliLogger;
import com.dtsx.docs.lib.JacksonUtils;
import com.dtsx.docs.runner.drivers.ClientLanguage;
import com.dtsx.docs.runner.snapshots.SnapshotSource;
import com.dtsx.docs.runner.snapshots.SnapshotSources;
import lombok.val;
import org.apache.commons.lang3.tuple.Pair;
import tools.jackson.core.JacksonException;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

import static com.dtsx.docs.lib.Constants.*;

/// **Note: Docs for this class were _partially_ generated by AI**
///
/// Builds a [TestPlan] by discovering and parsing test roots in the examples directory.
///
/// The build process:
/// 1. Finds all _test roots_ (directories containing a `meta.yml` file)
/// 2. Parses each `meta.yml` to get fixture and snapshot configuration
/// 3. Discovers example files (`example.<ext>`) for each client language
/// 4. Resolves base and test-specific fixtures
/// 5. Groups test roots by their base fixture
///
/// Example directory structure:
/// ```
/// examples/
///   _fixtures/
///     basic-collection.js  <- base fixture
///   dates/                 <- test root
///     meta.yml
///     example.ts
///     example.py
///     fixture.js           <- optional test-specific fixture
/// ```
///
/// @see TestPlan
/// @see TestRoot
/// @see MetaYml
public class TestPlanBuilder {
    /// Builds a complete {@linkplain TestPlan test plan} by discovering and processing all test roots.
    ///
    /// @param ctx the verifier context containing configuration and paths
    /// @return a test plan containing all discovered test roots grouped by base fixture
    /// @throws TestPlanException if any errors occur during plan building
    ///
    /// @see TestPlan
    public static TestPlan buildPlan(VerifierCtx ctx) {
        return CliLogger.loading("Building test plan...", (_) -> {
            val testRoots = findTestRoots(ctx.examplesFolder());

            CliLogger.println("@|faint Building test plan...|@");
            CliLogger.println("@|faint -> Found " + testRoots.size() + " test roots|@");

            val builder = new TestPlan.Builder();

            for (val testRoot : testRoots) {
                mkTestRoot(testRoot, ctx).ifPresent(builder::addRoot);
            }

            val plan = builder.build();

            CliLogger.println("@|faint -> Found " + plan.totalTests() + " example files to test|@");
            CliLogger.println();

            return plan;
        });
    }

    /// Finds all {@linkplain TestRoot test roots} in the examples directory.
    ///
    /// Example:
    /// ```
    /// examples/
    ///   _fixtures/        <- ignored (starts with _)
    ///   dates/
    ///     meta.yml        <- test root found
    ///   delete-many/
    ///     with-filter/
    ///       meta.yml      <- test root found
    /// ```
    ///
    /// @param examplesFolder the root examples directory to search
    /// @return list of paths to directories containing meta.yml files
    /// @throws TestPlanException if the examples folder doesn't exist or no test roots are found
    ///
    /// @see TestRoot
    private static List<Path> findTestRoots(Path examplesFolder) {
        if (!Files.exists(examplesFolder) || !Files.isDirectory(examplesFolder)) {
            throw new TestPlanException("Examples folder '" + examplesFolder + "' does not exist or is not a directory");
        }

        try (val files = Files.walk(examplesFolder)) {
            val dirs = files
                .skip(1)
                .filter(Files::isDirectory)
                .filter(path -> !path.getFileName().toString().startsWith("_"))
                .filter(path -> Files.exists(path.resolve(META_FILE)))
                .toList();

            if (dirs.isEmpty()) {
                throw new TestPlanException("No test roots found in examples directory '" + examplesFolder + "'");
            }

            return dirs;
        } catch (IOException e) {
            throw new TestPlanException("Failed to traverse examples directory '" + examplesFolder + "' to find test roots", e);
        }
    }

    /// Creates a test root from a directory containing a `meta.yml` file.
    ///
    /// Steps:
    /// 1. Parse `meta.yml` configuration
    /// 2. Skip if `skip: true` is set
    /// 3. Find all `example.<ext>` files for configured languages
    /// 4. Resolve base fixture from `_fixtures/` directory
    /// 5. Resolve test-specific fixture (if `fixture.js` exists)
    /// 6. Build snapshot sources from configuration
    ///
    /// @param testRoot path to the test root directory
    /// @param ctx the verifier context
    /// @return a pair of (base fixture, test root), or empty if skipped or no example files found
    private static Optional<Pair<JSFixture, TestRoot>> mkTestRoot(Path testRoot, VerifierCtx ctx) {
        val meta = parseMetaFile(testRoot.resolve(META_FILE));

        if (meta.skip().orElse(false)) {
            return Optional.empty();
        }

        val filesToTest = findFilesToTestInRoot(testRoot, ctx);

        if (filesToTest.isEmpty()) {
            return Optional.empty();
        }

        val baseFixture = resolveBaseFixture(ctx, meta.fixtures().base());
        val testFixture = resolveTestFixture(ctx, testRoot);

        val snapshotTypes = buildSnapshotTypes(meta.snapshots());
        val shareSnapshots = meta.snapshots().share().orElse(true);

        val testMetadata = new TestRoot(
            ctx,
            testRoot,
            filesToTest,
            testFixture,
            snapshotTypes,
            shareSnapshots
        );

        return Optional.of(Pair.of(baseFixture, testMetadata));
    }

    /// Parses a `meta.yml` file into a [MetaYml] object.
    ///
    /// @param metaFile path to the meta.yml file
    /// @return parsed [MetaYml] configuration
    /// @throws TestPlanException if parsing fails
    private static MetaYml parseMetaFile(Path metaFile) {
        try {
            return JacksonUtils.parseYaml(metaFile, MetaYml.class);
        } catch (JacksonException e) {
            throw new TestPlanException("Failed to parse " + metaFile, e);
        }
    }

    /// Finds all example files in a test root for the configured client languages.
    ///
    /// Searches for files named `example.<ext>` where `<ext>` matches a configured language extension.
    ///
    /// Example:
    /// ```
    /// dates/
    ///   example.ts         <- found for TypeScript
    ///   example.py         <- found for Python
    ///   java/
    ///     src/main/java/
    ///       Example.java   <- found for Java (example.java at any depth)
    /// ```
    ///
    /// @param root the test root directory to search
    /// @param ctx the verifier context containing language configuration
    /// @return map of client languages to their example file paths
    /// @throws TestPlanException if traversal fails
    private static TreeMap<ClientLanguage, Path> findFilesToTestInRoot(Path root, VerifierCtx ctx) {
        val ret = new TreeMap<ClientLanguage, Path>();

        try (val children = Files.walk(root).skip(1)) {
            children.forEach((child) -> {
                if (!Files.isRegularFile(child)) {
                    return;
                }

                val fileName = child.getFileName().toString().toLowerCase();

                for (val lang : ctx.languages()) {
                    if (fileName.equals("example" + lang.extension()) && ctx.filter().test(child)) {
                        ret.put(lang, child);
                        return;
                    }
                }
            });
        } catch (IOException e) {
            throw new TestPlanException("Failed to traverse test root '" + root + "' to find example files", e);
        }

        return ret;
    }

    /// Resolves a base fixture from the `_fixtures/` directory.
    ///
    /// Example:
    /// ```
    /// examples/
    ///   _fixtures/
    ///     basic-collection.js  <- resolves "basic-collection.js"
    /// ```
    ///
    /// @param ctx the verifier context
    /// @param fixtureName the fixture file name from meta.yml
    /// @return the resolved [JSFixture]
    /// @throws TestPlanException if the fixture doesn't exist
    ///
    /// @see JSFixture
    private static JSFixture resolveBaseFixture(VerifierCtx ctx, String fixtureName) {
        val path = ctx.examplesFolder().resolve(FIXTURES_DIR).resolve(fixtureName);

        if (!Files.exists(path)) {
            throw new TestPlanException("Base fixture '" + fixtureName + "' does not exist in '" + FIXTURES_DIR + "'");
        }

        return JSFixture.mkFor(ctx, path);
    }

    /// Resolves a test-specific fixture from the test root directory.
    ///
    /// Looks for `fixture.js` in the test root, if it exists; otherwise returns a no-op fixture.
    ///
    /// Example:
    /// ```
    /// examples/
    ///   dates/
    ///    fixture.js      <- resolves this file
    ///    meta.yml
    ///   delete-many/
    ///    (no fixture.js) <- resolves no-op fixture
    ///    meta.yml
    /// ```
    ///
    /// @param ctx the verifier context
    /// @param testRoot the test root directory
    /// @return the resolved [JSFixture] (or no-op if fixture.js doesn't exist)
    ///
    /// @see JSFixture
    private static JSFixture resolveTestFixture(VerifierCtx ctx, Path testRoot) {
        val path = testRoot.resolve(DEFAULT_TEST_FIXTURE);
        return JSFixture.mkFor(ctx, path);
    }

    /// Builds snapshot sources from the snapshots configuration.
    ///
    /// @param config the snapshots configuration from meta.yml
    /// @return set of configured snapshot sources
    /// @throws TestPlanException if unsupported parameters are provided
    ///
    /// @see SnapshotSources
    private static TreeSet<SnapshotSource> buildSnapshotTypes(SnapshotsConfig config) {
        val sources = new TreeSet<SnapshotSource>();

        for (val rawSource : config.sources().entrySet()) {
            val source = rawSource.getKey();
            val params = Objects.requireNonNullElse(rawSource.getValue(), Collections.<String, Object>emptyMap());

            if (params.keySet().stream().anyMatch(param -> !source.supportedParams().contains(param))) {
                throw new TestPlanException("Unsupported parameter found for snapshot source " + source.name() + ". Supported parameters are: " + String.join(", ", source.supportedParams()));
            }

            sources.add(source.create(params));
        }

        return sources;
    }
}
