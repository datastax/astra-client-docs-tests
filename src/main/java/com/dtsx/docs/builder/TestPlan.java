package com.dtsx.docs.builder;

import com.dtsx.docs.builder.fixtures.JSFixture;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.tuple.Pair;

import java.util.*;
import java.util.function.BiConsumer;

import static java.util.stream.Collectors.joining;

/// **Note: Docs for this class were generated by AI**
/// 
/// A test plan that groups [TestRoot]s by their base fixture for efficient test execution.
///
/// Test roots sharing the same base fixture are grouped together so the base fixture's
/// `Setup()` and `Teardown()` only need to run once for the entire group.
///
/// Example structure:
/// ```
/// TestPlan:
///   basic-collection.js (base fixture)
///     -> dates/ (test root)
///     -> find-many/ (test root)
///   empty-collection.js (base fixture)
///     -> delete-many/ (test root)
/// ```
///
/// @see TestRoot
/// @see JSFixture
@RequiredArgsConstructor
public class TestPlan {
    private final SequencedMap<JSFixture, SequencedSet<TestRoot>> planned;

    /// Iterates over each base fixture and its associated test roots, executing the consumer for each group.
    ///
    /// Example usage:
    /// ```java
    /// plan.forEachBaseFixture((baseFixture, testRoots) -> {
    ///     baseFixture.useResetting(tsx, testRoots, testRoot -> {
    ///         runTests(testRoot);
    ///     });
    /// });
    /// ```
    ///
    /// @param consumer function to execute for each (base fixture, test roots) pair
    public void forEachBaseFixture(BiConsumer<JSFixture, SequencedSet<TestRoot>> consumer) {
        planned.forEach(consumer);
    }

    /// Returns the total number of example files across all test roots.
    ///
    /// @return total count of example files to test
    public int totalTests() {
        return planned.values().stream().flatMap(Set::stream).mapToInt(root -> root.filesToTest().values().stream().mapToInt(Set::size).sum()).sum();
    }

    /// Builder for constructing a [TestPlan] by grouping test roots by their base fixture.
    public static class Builder {
        private final SequencedMap<JSFixture, SequencedSet<TestRoot>> planned = new LinkedHashMap<>();

        /// Adds a test root to the plan, grouping it with other roots sharing the same base fixture.
        ///
        /// @param pair a (base fixture, test root) pair
        public void addRoot(Pair<JSFixture, TestRoot> pair) {
            planned.computeIfAbsent(pair.getLeft(), _ -> new LinkedHashSet<>()).add(pair.getRight());
        }

        /// Builds the final test plan.
        ///
        /// @return the constructed TestPlan
        public TestPlan build() {
            return new TestPlan(planned);
        }
    }
}
