package com.dtsx.docs.lib;

import com.dtsx.docs.builder.TestRoot;
import com.dtsx.docs.config.VerifierCtx;
import com.dtsx.docs.lib.LoadingSpinner.LoadingSpinnerControls;
import com.dtsx.docs.runner.TestResults.TestOutcome;
import com.dtsx.docs.runner.drivers.ClientLanguage;
import lombok.Cleanup;
import lombok.NonNull;
import lombok.val;

import java.io.IOException;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.FileTime;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.Comparator;
import java.util.Optional;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.Consumer;
import java.util.function.Function;

import static com.dtsx.docs.lib.ColorUtils.stripAnsi;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.nio.file.StandardOpenOption.APPEND;
import static java.nio.file.StandardOpenOption.CREATE;

/// **Note: Docs for this class were generated by AI**
///
/// **Note: Adapted from Astra CLI**
///
/// Centralized logging utility that handles console output with optional loading spinners and automatic log file generation.
///
/// Log messages are written directly to `.docs_tests_temp/logs/<timestamp>.astra.log` asynchronously via a single-threaded executor.
/// Keeps only the 10 most recent log files.
///
/// Supports:
/// - Colored output via `@|color text|@` syntax (see [ColorUtils])
/// - Loading spinners that pause during log output
/// - Automatic ANSI stripping for log files
public class CliLogger {
    private static final LoadingSpinner globalSpinner = new LoadingSpinner();
    private static boolean spinnerEnabled;
    
    private static final String logFileName;
    private static final ExecutorService logExecutor = Executors.newSingleThreadExecutor();
    private static VerifierCtx ctx;
    
    static {
        val timestamp = DateTimeFormatter.ofPattern("yyyy_MM_dd___HH_mm_ss").format(Instant.now().atZone(ZoneId.systemDefault()));
        logFileName = timestamp + ".astra.log";
    }
    
    /// Initializes the logger with the verifier context.
    ///
    /// Must be called before any logging methods that write to file.
    ///
    /// @param verifierCtx the verifier context
    public static void initialize(VerifierCtx verifierCtx) {
        ctx = verifierCtx;
        try {
            val logFile = logsDir(ctx).resolve(logFileName);
            Files.createDirectories(logFile.getParent());
            deleteOldLogs(logsDir(ctx));
        } catch (Exception _) {}
    }

    /// Enables or disables the loading spinner.
    ///
    /// Controlled by `--spinner`/`--no-spinner` flags or `SPINNER` env var (default: true).
    /// When disabled, loading messages are printed directly instead of showing a spinner.
    public static void setSpinnerEnabled(boolean spinnerEnabled) {
        CliLogger.spinnerEnabled = spinnerEnabled;
    }

    /// Prints to stdout with a newline.
    public static void println(boolean appendToFile, String... msg) {
        log(appendToFile, String.join("", msg) + System.lineSeparator(), System.out);
    }

    /// Executes a function while showing a loading spinner with a message.
    ///
    /// The spinner can be updated mid-execution via the consumer parameter.
    /// Automatically pauses the spinner when other log methods are called.
    ///
    /// Example:
    /// ```java
    /// val result = loading("Installing dependencies...", (updateMsg) -> {
    ///     installNpm();
    ///     updateMsg.accept("Installing Python packages...");
    ///     installPip();
    ///     return "done";
    /// });
    /// ```
    ///
    /// @param initialMsg the initial spinner message (supports color formatting)
    /// @param supplier function that performs work and optionally updates the message
    /// @return the result from the supplier
    public static <T> T loading(@NonNull String initialMsg, Function<Consumer<String>, T> supplier) {
        val formattedMsg = ColorUtils.format(initialMsg);

        val controls = (spinnerEnabled)
            ? globalSpinner.start(formattedMsg)
            : Optional.<LoadingSpinnerControls>empty();

        try {
            return supplier.apply((msg) -> {
                controls.ifPresent(s -> s.updateMessage(ColorUtils.format(msg)));
            });
        } finally {
            controls.ifPresent(LoadingSpinnerControls::stop);
        }
    }

    /// Logs a debug message (only to log file, not console).
    ///
    /// Prefixed with `[DEBUG]` in the log file.
    public static void debug(String... msg) {
        writeToLogFile("DEBUG", String.join("", msg));
    }

    /// Logs the result of failed test executions (only to log file, not console).
    ///
    /// Prefixed with `[FAILED]` in the log file for failed tests.
    public static void result(TestRoot testRoot, ClientLanguage language, TestOutcome testOutcome, String extra) {
        if (testOutcome.passed()) {
            return;
        }

        writeToLogFile("FAILED", testRoot.rootName() + " (" + language + ") => " + testOutcome.name());

        if (!extra.isBlank()) {
            writeToLogFile("FAILED", extra);
        }
    }

    /// Logs an exception message (only to log file, not console).
    ///
    /// Prefixed with `[ERROR]` in the log file.
    public static void exception(String... msg) {
        writeToLogFile("EXCEPTION", String.join("", msg));
    }

    /// Logs an exception with a message and returns the exception for rethrowing (only to log file, not console).
    ///
    /// Example:
    /// ```java
    /// throw exception("Failed to parse file", new IOException("bad format"));
    /// ```
    public static <E extends Throwable> E exception(String msg, E e) {
        exception(msg, "\n", captureStackTrace(e));
        return e;
    }

    /// Logs an exception's stack trace and returns it for rethrowing (only to log file, not console).
    ///
    /// Example:
    /// ```java
    /// throw exception(new RuntimeException("oops"));
    /// ```
    public static <E extends Throwable> E exception(E e) {
        exception(captureStackTrace(e));
        return e;
    }

    /// Returns the absolute path to the log file for this session.
    ///
    /// The log file name is determined at static initialization time.
    ///
    /// @param ctx the verifier context
    /// @return the absolute path to the log file
    public static Path logFilePath(VerifierCtx ctx) {
        return logsDir(ctx).resolve(logFileName).toAbsolutePath();
    }

    private static void log(boolean appendToFile, String msg, PrintStream ps) {
        val formattedMsg = ColorUtils.format(msg);

        if (appendToFile) {
            writeToLogFile("OUTPUT", formattedMsg);
        }

        val resume = globalSpinner.pause();

        try {
            ps.print(formattedMsg);
            ps.flush();
        } finally {
            resume.run();
        }
    }

    private static void writeToLogFile(String tag, String msg) {
        if (ctx == null) {
            return;
        }
        
        logExecutor.submit(() -> {
            try {
                val logFile = logsDir(ctx).resolve(logFileName);

                val lines = stripAnsi(msg).trim().split("\n");

                try (val writer = Files.newBufferedWriter(logFile, UTF_8, CREATE, APPEND)) {
                    for (val line : lines) {
                        writer.write("[" + tag + "] " + line);
                        writer.newLine();
                    }
                }
            } catch (Exception e) {
                System.err.println("Failed to write to log file: " + e.getMessage());
            }
        });
    }

    private static void deleteOldLogs(Path logsDir) {
        try {
            @Cleanup val logFiles = Files.list(logsDir);

            logFiles
                .sorted(Comparator.<Path, FileTime>comparing((path) -> {
                    try {
                        return Files.getLastModifiedTime(path);
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                }).reversed())
                .skip(10)
                .forEach((f) -> {
                    try {
                        Files.delete(f);
                    } catch (Exception _) {}
                });
        } catch (Exception _) {}
    }

    public static String captureStackTrace(Throwable t) {
        val sw = new StringWriter();
        t.printStackTrace(new PrintWriter(sw));
        return sw.toString();
    }

    private static Path logsDir(VerifierCtx ctx) {
        return ctx.tmpFolder().resolve("logs");
    }
}
