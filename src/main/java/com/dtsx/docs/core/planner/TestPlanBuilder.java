package com.dtsx.docs.core.planner;

import com.dtsx.docs.commands.test.TestCtx;
import com.dtsx.docs.core.planner.TestPlan.Builder;
import com.dtsx.docs.core.planner.fixtures.JSFixture;
import com.dtsx.docs.core.planner.meta.BaseMetaYml.BaseMetaYmlRep.TestBlock.SkipConfig;
import com.dtsx.docs.core.planner.meta.MetaYmlParser;
import com.dtsx.docs.core.planner.meta.compiles.CompilesTestMeta;
import com.dtsx.docs.core.planner.meta.snapshot.SnapshotTestMeta;
import com.dtsx.docs.core.planner.meta.snapshot.SnapshotTestMetaRep;
import com.dtsx.docs.core.runner.drivers.ClientLanguage;
import com.dtsx.docs.core.runner.tests.strategies.test.CompilesTestStrategy;
import com.dtsx.docs.core.runner.tests.strategies.test.SnapshotTestStrategy;
import com.dtsx.docs.lib.CliLogger;
import lombok.val;
import org.apache.commons.lang3.tuple.Pair;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static com.dtsx.docs.lib.Constants.META_FILE;

/// **Note: Docs for this class were _partially_ generated by AI**
///
/// Builds a [TestPlan] by discovering and parsing test roots in the examples directory.
///
/// The build process:
/// 1. Finds all _test roots_ (directories containing a `meta.yml` file)
/// 2. Parses each `meta.yml` to get fixture and snapshot configuration
/// 3. Discovers example files (`example.<ext>`) for each client language
/// 4. Resolves base and test-specific fixtures
/// 5. Groups test roots by their base fixture
///
/// Example directory structure:
/// ```
/// examples/
///   _fixtures/
///     basic-collection.js  <- base fixture
///   dates/                 <- test root
///     meta.yml
///     example.ts
///     example.py
///     fixture.js           <- optional test-specific fixture
/// ```
///
/// @see TestPlan
/// @see TestRoot
/// @see SnapshotTestMetaRep
public class TestPlanBuilder {
    /// Builds a complete {@linkplain TestPlan test plan} by discovering and processing all test roots.
    ///
    /// @param ctx the verifier context containing configuration and paths
    /// @return a test plan containing all discovered test roots grouped by base fixture
    /// @throws PlanException if any errors occur during plan building
    ///
    /// @see TestPlan
    public static TestPlan buildPlan(TestCtx ctx) {
        return CliLogger.loading("Building test plan", (_) -> {
            val testRoots = findTestRoots(ctx.examplesFolder());

            CliLogger.println(true, "@|bold Building test plan...|@");
            CliLogger.println(true, "@!->!@ Found " + testRoots.size() + " test roots");

            // Build gitignore predicate once at the start
            val gitignorePredicate = buildGitignorePredicate(ctx.examplesFolder());

            val builder = new Builder();

            for (val rootPath : testRoots) {
                mkTestRoot(ctx, rootPath, gitignorePredicate).ifPresent(builder::addRoot);
            }

            val plan = builder.build(ctx.maxFixtureInstances());

            CliLogger.println(true, "@!->!@ Found " + plan.totalTests() + " files to test");
            CliLogger.println(true);

            if (plan.totalTests() == 0) {
                throw new PlanException("No tests found to run after building test plan");
            }

            return plan;
        });
    }

    /// Finds all {@linkplain TestRoot test roots} in the examples directory.
    ///
    /// Example:
    /// ```
    /// examples/
    ///   _fixtures/        <- ignored (starts with _)
    ///   dates/
    ///     meta.yml        <- test root found
    ///   delete-many/
    ///     with-filter/
    ///       meta.yml      <- test root found
    /// ```
    ///
    /// @param examplesFolder the root examples directory to search
    /// @return list of paths to directories containing meta.yml files
    /// @throws PlanException if the examples folder doesn't exist or no test roots are found
    ///
    /// @see TestRoot
    private static List<Path> findTestRoots(Path examplesFolder) {
        if (!Files.exists(examplesFolder) || !Files.isDirectory(examplesFolder)) {
            throw new PlanException("Examples folder '" + examplesFolder + "' does not exist or is not a directory");
        }

        try (val files = Files.walk(examplesFolder)) {
            val dirs = files
                .skip(1)
                .filter(Files::isDirectory)
                .filter(path -> !path.getFileName().toString().startsWith("_"))
                .filter(path -> Files.exists(path.resolve(META_FILE)))
                .toList();

            if (dirs.isEmpty()) {
                throw new PlanException("No test roots found in examples directory '" + examplesFolder + "'");
            }

            return dirs;
        } catch (IOException e) {
            throw new PlanException("Failed to traverse examples directory '" + examplesFolder + "' to find test roots", e);
        }
    }

    /// Builds a predicate from the .gitignore file in the examples folder.
    ///
    /// Reads the .gitignore file (if it exists) and converts each pattern into a predicate
    /// that tests whether a path should be ignored. Supports glob patterns like:
    /// - `**/bin/*` - matches bin directory at any depth
    /// - `**/obj/*` - matches obj directory at any depth
    /// - `target/*` - matches target directory at root level
    ///
    /// @param examplesFolder the examples folder to look for .gitignore
    /// @return a predicate that returns true if a path should be ignored
    private static Predicate<Path> buildGitignorePredicate(Path examplesFolder) {
        val gitignorePath = examplesFolder.resolve(".gitignore");

        if (!Files.exists(gitignorePath)) {
            // No .gitignore file, don't ignore anything
            return path -> false;
        }

        try {
            val patterns = Files.readAllLines(gitignorePath).stream()
                .map(String::trim)
                .filter(line -> !line.isEmpty() && !line.startsWith("#"))
                .map(TestPlanBuilder::gitignorePatternToRegex)
                .map(Pattern::compile)
                .collect(Collectors.toList());

            return path -> {
                val pathStr = path.toString();
                return patterns.stream().anyMatch(pattern -> pattern.matcher(pathStr).find());
            };
        } catch (IOException e) {
            CliLogger.println(false, "@|yellow Warning: Failed to read .gitignore file, ignoring it|@");
            return path -> false;
        }
    }

    /// Converts a gitignore pattern to a regex pattern.
    ///
    /// Handles common gitignore patterns:
    /// - `**` matches any number of directories
    /// - `*` matches any characters except directory separator
    /// - Literal directory separators
    ///
    /// @param gitignorePattern the gitignore pattern (e.g., "**/bin/*")
    /// @return a regex pattern string
    private static String gitignorePatternToRegex(String gitignorePattern) {
        // Escape special regex characters except * and /
        String regex = gitignorePattern
            .replace("\\", "\\\\")
            .replace(".", "\\.")
            .replace("+", "\\+")
            .replace("?", "\\?")
            .replace("|", "\\|")
            .replace("(", "\\(")
            .replace(")", "\\)")
            .replace("[", "\\[")
            .replace("]", "\\]")
            .replace("{", "\\{")
            .replace("}", "\\}")
            .replace("^", "\\^")
            .replace("$", "\\$");

        // Convert gitignore wildcards to regex
        regex = regex.replace("**/", "(.*/)?");  // ** matches any number of directories
        regex = regex.replace("**", ".*");        // ** at end matches anything
        regex = regex.replace("*", "[^/\\\\]*");  // * matches anything except path separator

        // Handle both forward and backward slashes
        regex = regex.replace("/", "[/\\\\]");

        return regex;
    }

    /// Creates a test root from a directory containing a `meta.yml` file.
    ///
    /// Steps:
    /// 1. Parse `meta.yml` configuration
    /// 2. Skip if `skip: true` is set
    /// 3. Find all `example.<ext>` files for configured languages
    /// 4. Resolve base fixture from `_fixtures/` directory
    /// 5. Resolve test-specific fixture (if `fixture.js` exists)
    /// 6. Build snapshot sources from configuration
    ///
    /// @param rootPath path to the test root directory
    /// @param ctx the verifier context
    /// @param gitignorePredicate predicate to test if paths should be ignored
    /// @return a pair of (base fixture, test root), or empty if skipped or no example files found
    private static Optional<Pair<JSFixture, TestRoot>> mkTestRoot(TestCtx ctx, Path rootPath, Predicate<Path> gitignorePredicate) {
        val meta = MetaYmlParser.parseMetaYml(ctx, rootPath.resolve(META_FILE));

        val filesToTest = findFilesToTestInRoot(rootPath, ctx, meta.skipConfig(), gitignorePredicate);

        if (filesToTest.isEmpty()) {
            return Optional.empty();
        }

        val strategy = switch (meta) {
            case SnapshotTestMeta m -> new SnapshotTestStrategy(ctx, m);
            case CompilesTestMeta m -> new CompilesTestStrategy(ctx, m);
            default -> throw new RuntimeException(); // unreachable
        };

        val testMetadata = new TestRoot(
            ctx,
            rootPath,
            filesToTest,
            strategy
        );

        return Optional.of(Pair.of(meta.baseFixture(), testMetadata));
    }

    /// Finds all example files in a test root for the configured client languages.
    ///
    /// Searches for files named `example.<ext>` where `<ext>` matches a configured language extension.
    /// Files matching patterns in .gitignore are excluded.
    ///
    /// Example:
    /// ```
    /// dates/
    ///   example.ts         <- found for TypeScript
    ///   example.py         <- found for Python
    ///   java/
    ///     src/main/java/
    ///       Example.java   <- found for Java (example.java at any depth)
    ///```
    ///
    /// @param root       the test root directory to search
    /// @param ctx        the verifier context containing language configuration
    /// @param skipConfig the skip configuration to check if any languages should be skipped
    /// @param gitignorePredicate predicate to test if paths should be ignored based on .gitignore
    /// @return map of client languages to their example file paths
    /// @throws PlanException if traversal fails
    private static TreeMap<ClientLanguage, Set<Path>> findFilesToTestInRoot(Path root, TestCtx ctx, SkipConfig skipConfig, Predicate<Path> gitignorePredicate) {
        val ret = new TreeMap<ClientLanguage, Set<Path>>();

        try (val children = Files.walk(root).skip(1)) {
            children.forEach((child) -> {
                if (!Files.isRegularFile(child)) {
                    return;
                }

                // Skip files matching .gitignore patterns
                if (gitignorePredicate.test(child)) {
                    return;
                }

                tryAppendChild(ctx, skipConfig, child, ret);
            });
        } catch (IOException e) {
            throw new PlanException("Failed to traverse test root '" + root + "' to find example files", e);
        }

        return ret;
    }

    private static void tryAppendChild(TestCtx ctx, SkipConfig skipConfig, Path child, TreeMap<ClientLanguage, Set<Path>> ret) {
        val fileName = child.getFileName().toString();

        for (val lang : ctx.languages()) {
            if (fileName.endsWith(lang.extension()) && ctx.filter().test(child)) {
                if (skipConfig.isSkipped(lang)) {
                    return;
                }
                ret.computeIfAbsent(lang, _ -> new HashSet<>()).add(child);
                return;
            }
        }
    }
}
